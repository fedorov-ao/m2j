diff -U 10 -r evdev-1.7.0/evdev/device.py evdev-1.7.0-py27/evdev/device.py
--- evdev-1.7.0/evdev/device.py	2024-02-19 10:38:14.919457200 +0300
+++ evdev-1.7.0-py27/evdev/device.py	2024-02-19 10:07:03.590085200 +0300
@@ -284,21 +284,21 @@
     def __repr__(self):
         msg = (self.__class__.__name__, self.path)
         return "{}({!r})".format(*msg)
 
     def __fspath__(self):
         return self.path
 
     def close(self):
         if self.fd > -1:
             try:
-                super().close()
+                EventIO.close(self)
                 os.close(self.fd)
             finally:
                 self.fd = -1
 
     def grab(self):
         """
         Grab input device using ``EVIOCGRAB`` - other applications will
         be unable to receive events until the device is released. Only
         one process can hold a ``EVIOCGRAB`` on a device.
 
diff -U 10 -r evdev-1.7.0/evdev/ecodes.c evdev-1.7.0-py27/evdev/ecodes.c
--- evdev-1.7.0/evdev/ecodes.c	2024-02-19 10:42:10.292446700 +0300
+++ evdev-1.7.0-py27/evdev/ecodes.c	2024-02-19 12:23:38.751934900 +0300
@@ -10,36 +10,43 @@
 /* Automatically generated by evdev.genecodes */
 /* Generated on Linux 5.4.0-150-generic #167~18.04.1-Ubuntu SMP Wed May 24 00:51:14 UTC 2023 i686 */
 
 #define MODULE_NAME "_ecodes"
 #define MODULE_HELP "linux/input.h macros"
 
 static PyMethodDef MethodTable[] = {
     { NULL, NULL, 0, NULL}
 };
 
+#if PY_MAJOR_VERSION >= 3
 static struct PyModuleDef moduledef = {
     PyModuleDef_HEAD_INIT,
     MODULE_NAME,
     MODULE_HELP,
     -1,          /* m_size */
     MethodTable, /* m_methods */
     NULL,        /* m_reload */
     NULL,        /* m_traverse */
     NULL,        /* m_clear */
     NULL,        /* m_free */
 };
+#endif
 
-PyMODINIT_FUNC
-PyInit__ecodes(void)
+static PyObject *
+moduleinit(void)
 {
+
+#if PY_MAJOR_VERSION >= 3
     PyObject* m = PyModule_Create(&moduledef);
+#else
+    PyObject* m = Py_InitModule3(MODULE_NAME, MethodTable, MODULE_HELP);
+#endif
     if (m == NULL) return NULL;
 
     PyModule_AddIntMacro(m, EV_VERSION);
     PyModule_AddIntMacro(m, ID_BUS);
     PyModule_AddIntMacro(m, ID_VENDOR);
     PyModule_AddIntMacro(m, ID_PRODUCT);
     PyModule_AddIntMacro(m, ID_VERSION);
     PyModule_AddIntMacro(m, BUS_PCI);
     PyModule_AddIntMacro(m, BUS_ISAPNP);
     PyModule_AddIntMacro(m, BUS_USB);
@@ -788,10 +795,24 @@
     PyModule_AddIntMacro(m, SND_TONE);
     PyModule_AddIntMacro(m, SND_MAX);
     PyModule_AddIntMacro(m, SND_CNT);
     PyModule_AddIntMacro(m, EV_UINPUT);
     PyModule_AddIntMacro(m, UI_FF_UPLOAD);
     PyModule_AddIntMacro(m, UI_FF_ERASE);
 
     return m;
 }
 
+#if PY_MAJOR_VERSION >= 3
+PyMODINIT_FUNC
+PyInit__ecodes(void)
+{
+    return moduleinit();
+}
+#else
+PyMODINIT_FUNC
+init_ecodes(void)
+{
+    moduleinit();
+}
+#endif
+
diff -U 10 -r evdev-1.7.0/evdev/genecodes.py evdev-1.7.0-py27/evdev/genecodes.py
--- evdev-1.7.0/evdev/genecodes.py	2024-02-19 10:38:14.929418400 +0300
+++ evdev-1.7.0-py27/evdev/genecodes.py	2024-02-19 10:23:46.608418500 +0300
@@ -40,42 +40,63 @@
 /* Automatically generated by evdev.genecodes */
 /* Generated on %s */
 
 #define MODULE_NAME "_ecodes"
 #define MODULE_HELP "linux/input.h macros"
 
 static PyMethodDef MethodTable[] = {
     { NULL, NULL, 0, NULL}
 };
 
+#if PY_MAJOR_VERSION >= 3
 static struct PyModuleDef moduledef = {
     PyModuleDef_HEAD_INIT,
     MODULE_NAME,
     MODULE_HELP,
     -1,          /* m_size */
     MethodTable, /* m_methods */
     NULL,        /* m_reload */
     NULL,        /* m_traverse */
     NULL,        /* m_clear */
     NULL,        /* m_free */
 };
+#endif
 
-PyMODINIT_FUNC
-PyInit__ecodes(void)
+static PyObject *
+moduleinit(void)
 {
+
+#if PY_MAJOR_VERSION >= 3
     PyObject* m = PyModule_Create(&moduledef);
+#else
+    PyObject* m = Py_InitModule3(MODULE_NAME, MethodTable, MODULE_HELP);
+#endif
     if (m == NULL) return NULL;
 
 %s
 
     return m;
 }
+
+#if PY_MAJOR_VERSION >= 3
+PyMODINIT_FUNC
+PyInit__ecodes(void)
+{
+    return moduleinit();
+}
+#else
+PyMODINIT_FUNC
+init_ecodes(void)
+{
+    moduleinit();
+}
+#endif
 """
 
 
 def parse_header(header):
     for line in open(header):
         macro = macro_regex.search(line)
         if macro:
             yield "    PyModule_AddIntMacro(m, %s);" % macro.group(1)
 
 
diff -U 10 -r evdev-1.7.0/evdev/uinput.py evdev-1.7.0-py27/evdev/uinput.py
--- evdev-1.7.0/evdev/uinput.py	2024-02-19 10:38:14.935462500 +0300
+++ evdev-1.7.0-py27/evdev/uinput.py	2024-02-19 12:16:55.832244500 +0300
@@ -33,29 +33,29 @@
         "product",
         "version",
         "bustype",
         "events",
         "devnode",
         "fd",
         "device",
     )
 
     @classmethod
-    def from_device(cls, *devices, filtered_types=(ecodes.EV_SYN, ecodes.EV_FF), **kwargs):
+    def from_device(cls, devices, filtered_types=(ecodes.EV_SYN, ecodes.EV_FF), **kwargs):
         """
         Create an UInput device with the capabilities of one or more input
         devices.
 
         Arguments
         ---------
         devices : InputDevice|str
-          Varargs of InputDevice instances or paths to input devices.
+          Sequence of InputDevice instances or paths to input devices.
 
         filtered_types : Tuple[event type codes]
           Event types to exclude from the capabilities of the uinput device.
 
         **kwargs
           Keyword arguments to UInput constructor (i.e. name, vendor etc.).
         """
 
         device_instances = []
         for dev in devices:
@@ -307,29 +307,33 @@
 
         # If we're not running or Linux or the above method fails for any reason,
         # use the generic fallback method.
         return self._find_device_fallback()
 
     def _find_device_linux(self, sysname):
         """
         Tries to find the device node when running on Linux.
         """
 
-        syspath = f"/sys/devices/virtual/input/{sysname}"
+        import exceptions
+        class FileNotFoundError(exceptions.OSError):
+          pass
+
+        syspath = "/sys/devices/virtual/input/{sysname}".format(sysname=sysname)
 
         # The sysfs entry for event devices should contain exactly one folder
         # whose name matches the format "event[0-9]+". It is then assumed that
         # the device node in /dev/input uses the same name.
         regex = re.compile("event[0-9]+")
         for entry in os.listdir(syspath):
-            if regex.fullmatch(entry):
-                device_path = f"/dev/input/{entry}"
+            if regex.match(entry):
+                device_path = "/dev/input/{entry}".format(entry=entry)
                 break
         else:  # no break
             raise FileNotFoundError()
 
         # It is possible that there is some delay before /dev/input/event* shows
         # up on old systems that do not use devtmpfs, so if the device cannot be
         # found, wait for a short amount and then try again once.
         try:
             return device.InputDevice(device_path)
         except FileNotFoundError:
@@ -346,24 +350,24 @@
         time.sleep(0.1)
 
         # There could also be another device with the same name already present,
         # make sure to select the newest one.
         # Strictly speaking, we cannot be certain that everything returned by list_devices()
         # ends at event[0-9]+: it might return something like "/dev/input/events_all". Find
         # the devices that have the expected structure and extract their device number.
         path_number_pairs = []
         regex = re.compile("/dev/input/event([0-9]+)")
         for path in util.list_devices("/dev/input/"):
-            regex_match = regex.fullmatch(path)
+            regex_match = regex.match(path)
             if not regex_match:
                 continue
-            device_number = int(regex_match[1])
+            device_number = int(regex_match.group(1))
             path_number_pairs.append((path, device_number))
 
         # The modification date of the devnode is not reliable unfortunately, so we
         # are sorting by the number in the name
         path_number_pairs.sort(key=lambda pair: pair[1], reverse=True)
 
         for path, _ in path_number_pairs:
             d = device.InputDevice(path)
             if d.name == self.name:
                 return d

diff -U 10 -r evdev-1.7.0/setup.py evdev-1.7.0-py27/setup.py
--- evdev-1.7.0/setup.py	2024-02-19 10:38:14.948150700 +0300
+++ evdev-1.7.0-py27/setup.py	2024-02-19 11:53:17.777145000 +0300
@@ -1,14 +1,16 @@
+#!/usr/bin/env python
+
 import os
 import sys
 import textwrap
-from pathlib import Path
+from pathlib2 import Path
 
 from setuptools import setup, Extension, Command
 from setuptools.command import build_ext as _build_ext
 
 
 curdir = Path(__file__).resolve().parent
 ecodes_path = curdir / "evdev/ecodes.c"
 
 
 def create_ecodes(headers=None):
@@ -45,26 +47,26 @@
             python setup.py \\
               build \\
               build_ecodes --evdev-headers path/input.h:path/input-event-codes.h \\
               build_ext --include-dirs path/ \\
               install
         """
 
         sys.stderr.write(textwrap.dedent(msg))
         sys.exit(1)
 
-    from subprocess import run
+    from subprocess import call
 
     print("writing %s (using %s)" % (ecodes_path, " ".join(headers)))
     with ecodes_path.open("w") as fh:
-        cmd = [sys.executable, "evdev/genecodes.py", *headers]
-        run(cmd, check=True, stdout=fh)
+        cmd = [sys.executable, 'evdev/genecodes.py'] + headers
+        call(cmd, stdout=fh)
 
 
 class build_ecodes(Command):
     description = "generate ecodes.c"
 
     user_options = [
         ("evdev-headers=", None, "colon-separated paths to input subsystem headers"),
     ]
 
     def initialize_options(self):
@@ -85,22 +87,52 @@
         return not ecodes_path.exists()
 
     def run(self):
         for cmd_name in self.get_sub_commands():
             self.run_command(cmd_name)
         _build_ext.build_ext.run(self)
 
     sub_commands = [("build_ecodes", has_ecodes)] + _build_ext.build_ext.sub_commands
 
 
+classifiers = [
+    'Development Status :: 5 - Production/Stable',
+    'Programming Language :: Python :: 2',
+    'Programming Language :: Python :: 2.7',
+    'Operating System :: POSIX :: Linux',
+    'Intended Audience :: Developers',
+    'Topic :: Software Development :: Libraries',
+    'License :: OSI Approved :: BSD License',
+    'Programming Language :: Python :: Implementation :: CPython',
+]
+
 cflags = ["-std=c99", "-Wno-error=declaration-after-statement"]
-setup(
-    ext_modules=[
+kw = {
+    'name':                 'evdev',
+    'version':              '1.7.0',
+
+    'description':          'Bindings to the Linux input handling subsystem',
+    'long_description':     (curdir / 'README.rst').read_text(),
+
+    'author':               'Georgi Valkov',
+    'author_email':         'georgi.t.valkov@gmail.com',
+    'license':              'Revised BSD License',
+    'keywords':             'evdev input uinput',
+    'url':                  'https://github.com/gvalkov/python-evdev',
+    'classifiers':          classifiers,
+
+    'packages':             ['evdev'],
+    'ext_modules':          [
         Extension("evdev._input", sources=["evdev/input.c"], extra_compile_args=cflags),
         Extension("evdev._uinput", sources=["evdev/uinput.c"], extra_compile_args=cflags),
         Extension("evdev._ecodes", sources=["evdev/ecodes.c"], extra_compile_args=cflags),
     ],
-    cmdclass={
+    'include_package_data': False,
+    'zip_safe':             True,
+    'cmdclass':             {
         "build_ext": build_ext,
         "build_ecodes": build_ecodes,
-    },
-)
+    }
+}
+
+if __name__ == '__main__':
+    setup(**kw)
